<!doctype html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atom-Universum</title>
    <style>
      :root {
        color-scheme: dark;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: "Segoe UI", system-ui, sans-serif;
        background: radial-gradient(circle at top, #090b1a, #03030b 60%, #000);
        color: #f4f6ff;
      }

      #scene {
        width: 100%;
        height: 100%;
        display: block;
      }

      .hud {
        position: absolute;
        top: 16px;
        left: 16px;
        max-width: 360px;
        padding: 14px 18px;
        background: rgba(10, 12, 30, 0.65);
        border: 1px solid rgba(120, 140, 255, 0.25);
        border-radius: 12px;
        backdrop-filter: blur(6px);
        box-shadow: 0 12px 30px rgba(3, 6, 30, 0.6);
      }

      .hud h1 {
        font-size: 18px;
        margin: 0 0 8px;
      }

      .hud p {
        margin: 0 0 10px;
        font-size: 13px;
        line-height: 1.4;
        color: rgba(240, 244, 255, 0.85);
      }

      .hud label {
        display: block;
        font-size: 12px;
        margin-top: 10px;
        color: rgba(220, 226, 255, 0.9);
      }

      .hud input[type="range"] {
        width: 100%;
        margin-top: 6px;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        color: rgba(170, 190, 255, 0.8);
      }

      .badge span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
        background: linear-gradient(120deg, #89a7ff, #5b6cff);
      }
    </style>
  </head>
  <body>
    <div class="hud">
      <h1>Atom-Universum</h1>
      <p>
        Atom-Modell im Weltraum: Elektronen sind eigene kleine Atome. Klick auf ein
        Objekt fixiert die Kamera, weiterer Klick zoomt näher heran. Ziehen rotiert
        die Ansicht.
      </p>
      <label for="zoom">Zoom-Fokus</label>
      <input id="zoom" type="range" min="0.4" max="3.4" step="0.01" value="1" />
      <div class="badge">
        <span></span>
        Kern + 6 Elektronen-Atome mit eigenen Körpern
      </div>
    </div>
    <canvas id="scene"></canvas>

    <script>
      const canvas = document.getElementById("scene");
      const ctx = canvas.getContext("2d");
      const zoomInput = document.getElementById("zoom");

      const camera = {
        yaw: 0,
        pitch: 0.18,
        distance: 820,
        target: { x: 0, y: 0, z: 0 },
        locked: null,
        zoomStep: 0,
        zoom: Number(zoomInput.value),
      };

      const stars = Array.from({ length: 520 }).map(() => ({
        x: (Math.random() - 0.5) * 4200,
        y: (Math.random() - 0.5) * 2400,
        z: (Math.random() - 0.5) * 3600,
        size: Math.random() * 1.8 + 0.4,
        alpha: Math.random() * 0.6 + 0.2,
      }));

      const nucleus = {
        name: "Atomkern",
        color: "#ffd36f",
        glow: "rgba(255, 184, 90, 0.7)",
        size: 90,
        position: { x: 0, y: 0, z: 0 },
        focusDistance: 240,
        children: [],
      };

      const createElectronAtom = (name, radius, angle, speed, tilt, color) => {
        const electron = {
          name,
          color,
          glow: "rgba(120, 180, 255, 0.45)",
          size: 34,
          orbit: { radius, angle, speed, tilt },
          position: { x: 0, y: 0, z: 0 },
          focusDistance: 160,
          children: [],
        };

        electron.children = [
          {
            name: `${name} - Kern` ,
            color: color.core,
            glow: color.glow,
            size: 22,
            position: { x: 0, y: 0, z: 0 },
            focusDistance: 120,
            children: [
              {
                name: `${name} - Mond A`,
                color: color.moonA,
                glow: "rgba(220, 220, 255, 0.35)",
                size: 9,
                orbit: { radius: 52, angle: 0.4, speed: 0.004, tilt: 0.7 },
                position: { x: 0, y: 0, z: 0 },
                focusDistance: 90,
                children: [
                  {
                    name: `${name} - Mini A1`,
                    color: "#f4f6ff",
                    glow: "rgba(244, 246, 255, 0.4)",
                    size: 6,
                    orbit: { radius: 20, angle: 1.1, speed: 0.007, tilt: -0.4 },
                    position: { x: 0, y: 0, z: 0 },
                    focusDistance: 70,
                    children: [],
                  },
                ],
              },
              {
                name: `${name} - Mond B`,
                color: color.moonB,
                glow: "rgba(200, 230, 255, 0.35)",
                size: 8,
                orbit: { radius: 72, angle: 2.2, speed: 0.0032, tilt: -0.5 },
                position: { x: 0, y: 0, z: 0 },
                focusDistance: 90,
                children: [
                  {
                    name: `${name} - Mini B1`,
                    color: "#e8f0ff",
                    glow: "rgba(232, 240, 255, 0.35)",
                    size: 5,
                    orbit: { radius: 18, angle: 2.7, speed: 0.0065, tilt: 0.3 },
                    position: { x: 0, y: 0, z: 0 },
                    focusDistance: 70,
                    children: [],
                  },
                ],
              },
            ],
          },
        ];

        return electron;
      };

      const electronAtoms = [
        createElectronAtom("Elektron-Atom A", 300, 0.4, 0.0007, 0.6, {
          core: "#7cf0ff",
          glow: "rgba(124, 240, 255, 0.45)",
          moonA: "#9ed0ff",
          moonB: "#d0e6ff",
        }),
        createElectronAtom("Elektron-Atom B", 370, 1.2, 0.0006, -0.4, {
          core: "#ff8bd9",
          glow: "rgba(255, 139, 217, 0.45)",
          moonA: "#ffc1ec",
          moonB: "#ffd8f4",
        }),
        createElectronAtom("Elektron-Atom C", 450, 2.3, 0.00055, 0.2, {
          core: "#a4ffb2",
          glow: "rgba(164, 255, 178, 0.45)",
          moonA: "#c7ffd6",
          moonB: "#e1ffea",
        }),
        createElectronAtom("Elektron-Atom D", 520, 3.4, 0.0005, -0.7, {
          core: "#ffdd7a",
          glow: "rgba(255, 221, 122, 0.45)",
          moonA: "#fff0b0",
          moonB: "#fff6d2",
        }),
        createElectronAtom("Elektron-Atom E", 600, 4.2, 0.00045, 0.4, {
          core: "#b7a4ff",
          glow: "rgba(183, 164, 255, 0.45)",
          moonA: "#d3c6ff",
          moonB: "#e8e1ff",
        }),
        createElectronAtom("Elektron-Atom F", 680, 5.2, 0.0004, -0.2, {
          core: "#7ccaff",
          glow: "rgba(124, 202, 255, 0.45)",
          moonA: "#a9ddff",
          moonB: "#d6f0ff",
        }),
      ];

      nucleus.children = electronAtoms;

      const flattenBodies = (root) => {
        const stack = [root];
        const all = [];
        while (stack.length) {
          const current = stack.pop();
          all.push(current);
          if (current.children) {
            current.children.forEach((child) => stack.push(child));
          }
        }
        return all;
      };

      const allBodies = flattenBodies(nucleus);

      const resize = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      };

      const rotatePoint = (point, yaw, pitch) => {
        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        const cosP = Math.cos(pitch);
        const sinP = Math.sin(pitch);

        let x = point.x * cosY - point.z * sinY;
        let z = point.x * sinY + point.z * cosY;
        let y = point.y;

        const y2 = y * cosP - z * sinP;
        const z2 = y * sinP + z * cosP;
        return { x, y: y2, z: z2 };
      };

      const projectPoint = (point) => {
        const relative = {
          x: point.x - camera.target.x,
          y: point.y - camera.target.y,
          z: point.z - camera.target.z,
        };
        const rotated = rotatePoint(relative, camera.yaw, camera.pitch);
        const depth = camera.distance + rotated.z;
        const scale = camera.zoom * (camera.distance / Math.max(depth, 80));
        return {
          x: rotated.x * scale + canvas.width / 2,
          y: rotated.y * scale + canvas.height / 2,
          scale,
          depth,
        };
      };

      const drawGlow = (x, y, radius, glowColor) => {
        const gradient = ctx.createRadialGradient(x, y, radius * 0.2, x, y, radius * 2.2);
        gradient.addColorStop(0, glowColor);
        gradient.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius * 2.2, 0, Math.PI * 2);
        ctx.fill();
      };

      const drawBody = (body) => {
        const projected = projectPoint(body.position);
        const radius = body.size * projected.scale;
        drawGlow(projected.x, projected.y, radius, body.glow);
        const gradient = ctx.createRadialGradient(
          projected.x - radius * 0.3,
          projected.y - radius * 0.3,
          radius * 0.2,
          projected.x,
          projected.y,
          radius
        );
        gradient.addColorStop(0, "rgba(255,255,255,0.9)");
        gradient.addColorStop(0.45, body.color);
        gradient.addColorStop(1, "rgba(0,0,0,0.2)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(projected.x, projected.y, radius, 0, Math.PI * 2);
        ctx.fill();
        return projected;
      };

      const updateOrbit = (body, delta) => {
        if (!body.orbit) return;
        body.orbit.angle += body.orbit.speed * delta;
        const localX = Math.cos(body.orbit.angle) * body.orbit.radius;
        const localY = Math.sin(body.orbit.angle) * body.orbit.radius * Math.cos(body.orbit.tilt);
        const localZ = Math.sin(body.orbit.angle) * body.orbit.radius * Math.sin(body.orbit.tilt);
        body.position = { x: localX, y: localY, z: localZ };
      };

      const updateHierarchy = (root, delta, basePosition = { x: 0, y: 0, z: 0 }) => {
        if (root.orbit) {
          updateOrbit(root, delta);
          root.position = {
            x: root.position.x + basePosition.x,
            y: root.position.y + basePosition.y,
            z: root.position.z + basePosition.z,
          };
        } else {
          root.position = { ...basePosition };
        }

        if (root.children) {
          root.children.forEach((child) => updateHierarchy(child, delta, root.position));
        }
      };

      const drawStars = () => {
        ctx.save();
        ctx.fillStyle = "#d8deff";
        stars.forEach((star) => {
          const projected = projectPoint(star);
          const size = star.size * projected.scale * 0.6;
          ctx.globalAlpha = star.alpha;
          ctx.beginPath();
          ctx.arc(projected.x, projected.y, size, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.restore();
      };

      const drawScene = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawStars();
        const sorted = [...allBodies].sort((a, b) => {
          const da = projectPoint(a.position).depth;
          const db = projectPoint(b.position).depth;
          return db - da;
        });
        sorted.forEach(drawBody);
      };

      const focusOn = (body) => {
        camera.target = { ...body.position };
        camera.locked = body;
        camera.distance = body.focusDistance || 220;
      };

      const findBodyAt = (x, y) => {
        const candidates = [...allBodies].reverse();
        for (const body of candidates) {
          const projected = projectPoint(body.position);
          const radius = body.size * projected.scale;
          if (Math.hypot(x - projected.x, y - projected.y) <= radius + 8) {
            return body;
          }
        }
        return null;
      };

      let lastTime = 0;
      let dragging = false;
      let lastPointer = { x: 0, y: 0 };

      const step = (timestamp) => {
        if (!lastTime) lastTime = timestamp;
        const delta = Math.min(32, timestamp - lastTime);
        lastTime = timestamp;

        updateHierarchy(nucleus, delta);

        if (camera.locked) {
          camera.target.x += (camera.locked.position.x - camera.target.x) * 0.06;
          camera.target.y += (camera.locked.position.y - camera.target.y) * 0.06;
          camera.target.z += (camera.locked.position.z - camera.target.z) * 0.06;
        }

        camera.zoom += (Number(zoomInput.value) - camera.zoom) * 0.08;

        drawScene();
        requestAnimationFrame(step);
      };

      const onPointerDown = (event) => {
        dragging = true;
        lastPointer = { x: event.clientX, y: event.clientY };
        const hit = findBodyAt(event.clientX, event.clientY);
        if (hit) {
          if (camera.locked === hit) {
            camera.distance = Math.max(90, camera.distance * 0.85);
          } else {
            focusOn(hit);
          }
        }
      };

      const onPointerMove = (event) => {
        if (!dragging) return;
        const dx = event.clientX - lastPointer.x;
        const dy = event.clientY - lastPointer.y;
        lastPointer = { x: event.clientX, y: event.clientY };
        camera.yaw += dx * 0.003;
        camera.pitch = Math.max(-0.8, Math.min(0.8, camera.pitch + dy * 0.003));
      };

      const onPointerUp = () => {
        dragging = false;
      };

      zoomInput.addEventListener("input", () => {
        camera.distance = 820 - (Number(zoomInput.value) - 1) * 200;
      });

      window.addEventListener("pointerdown", onPointerDown);
      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
      window.addEventListener("resize", resize);

      resize();
      requestAnimationFrame(step);
    </script>
  </body>
</html>
