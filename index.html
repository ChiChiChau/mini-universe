<!doctype html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atom-Universum</title>
    <style>
      :root {
        color-scheme: dark;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: "Segoe UI", system-ui, sans-serif;
        background: radial-gradient(circle at top, #0b0b1a, #03030b 60%, #000);
        color: #f4f6ff;
      }

      #scene {
        width: 100%;
        height: 100%;
        display: block;
      }

      .hud {
        position: absolute;
        top: 16px;
        left: 16px;
        max-width: 340px;
        padding: 14px 18px;
        background: rgba(10, 12, 30, 0.65);
        border: 1px solid rgba(120, 140, 255, 0.25);
        border-radius: 12px;
        backdrop-filter: blur(6px);
        box-shadow: 0 12px 30px rgba(3, 6, 30, 0.6);
      }

      .hud h1 {
        font-size: 18px;
        margin: 0 0 8px;
      }

      .hud p {
        margin: 0 0 10px;
        font-size: 13px;
        line-height: 1.4;
        color: rgba(240, 244, 255, 0.85);
      }

      .hud label {
        display: block;
        font-size: 12px;
        margin-top: 10px;
        color: rgba(220, 226, 255, 0.9);
      }

      .hud input[type="range"] {
        width: 100%;
        margin-top: 6px;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        color: rgba(170, 190, 255, 0.8);
      }

      .badge span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
        background: linear-gradient(120deg, #89a7ff, #5b6cff);
      }
    </style>
  </head>
  <body>
    <div class="hud">
      <h1>Atom-Universum</h1>
      <p>
        Klick auf ein Objekt, um dich heranzuzoomen. Ziehen zum Drehen, Scrollen zum
        Zoomen. Die Bahnen sind absichtlich geneigt wie in einem atomaren Orbit.
      </p>
      <label for="zoom">Zoom-Fokus</label>
      <input id="zoom" type="range" min="0.5" max="3" step="0.01" value="1" />
      <div class="badge">
        <span></span>
        1 Schwarzes Loch, 2 Sonnen, 3 Planeten, 2 Monde
      </div>
    </div>
    <canvas id="scene"></canvas>

    <script>
      const canvas = document.getElementById("scene");
      const ctx = canvas.getContext("2d");
      const zoomInput = document.getElementById("zoom");

      const camera = {
        x: 0,
        y: 0,
        zoom: Number(zoomInput.value),
        targetX: 0,
        targetY: 0,
        targetZoom: Number(zoomInput.value),
      };

      const bodies = [
        {
          name: "Schwarzes Loch",
          color: "#0b0b12",
          glow: "rgba(104, 120, 255, 0.45)",
          size: 48,
          focusZoom: 2.2,
          position: { x: -280, y: 80 },
          wobble: { x: 0.3, y: 0.1 },
          type: "black-hole",
        },
        {
          name: "Sonne A",
          color: "#ffd06a",
          glow: "rgba(255, 150, 72, 0.6)",
          size: 56,
          focusZoom: 1.8,
          position: { x: 80, y: -10 },
        },
        {
          name: "Sonne B",
          color: "#8bd9ff",
          glow: "rgba(88, 118, 255, 0.6)",
          size: 40,
          focusZoom: 1.9,
          position: { x: 200, y: 80 },
        },
        {
          name: "Planet Aria",
          color: "#4cffc6",
          glow: "rgba(76, 255, 198, 0.3)",
          size: 26,
          focusZoom: 2.6,
          orbit: { radius: 180, speed: 0.002, angle: 0.4, tilt: 0.6 },
        },
        {
          name: "Planet Lys",
          color: "#ff7ac1",
          glow: "rgba(255, 122, 193, 0.35)",
          size: 22,
          focusZoom: 2.6,
          orbit: { radius: 250, speed: 0.0014, angle: 1.2, tilt: -0.4 },
        },
        {
          name: "Planet Umbra",
          color: "#9f88ff",
          glow: "rgba(159, 136, 255, 0.35)",
          size: 30,
          focusZoom: 2.4,
          orbit: { radius: 320, speed: 0.001, angle: 2.4, tilt: 0.2 },
        },
      ];

      const moons = [
        {
          name: "Mond Nera",
          color: "#cbd6ff",
          glow: "rgba(203, 214, 255, 0.45)",
          size: 12,
          focusZoom: 3,
          parent: "Planet Aria",
          orbit: { radius: 48, speed: 0.008, angle: 0.4, tilt: 0.8 },
        },
        {
          name: "Mond Lyra",
          color: "#f0d9ff",
          glow: "rgba(240, 217, 255, 0.45)",
          size: 14,
          focusZoom: 3,
          parent: "Planet Umbra",
          orbit: { radius: 54, speed: 0.007, angle: 1.4, tilt: -0.6 },
        },
      ];

      const stars = Array.from({ length: 380 }).map(() => ({
        x: (Math.random() - 0.5) * 1600,
        y: (Math.random() - 0.5) * 900,
        size: Math.random() * 2 + 0.6,
        alpha: Math.random() * 0.6 + 0.3,
      }));

      const orbitDefs = [
        { radius: 180, tilt: 0.6, color: "rgba(95, 123, 255, 0.4)" },
        { radius: 250, tilt: -0.4, color: "rgba(138, 162, 255, 0.4)" },
        { radius: 320, tilt: 0.2, color: "rgba(155, 182, 255, 0.4)" },
      ];

      const mouse = { down: false, x: 0, y: 0 };
      let spin = 0;

      const resize = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      };

      const drawGlow = (x, y, size, glowColor) => {
        const gradient = ctx.createRadialGradient(x, y, size * 0.3, x, y, size * 2.8);
        gradient.addColorStop(0, glowColor);
        gradient.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, size * 2.8, 0, Math.PI * 2);
        ctx.fill();
      };

      const drawBody = (body) => {
        const screenX = (body.position.x - camera.x) * camera.zoom + canvas.width / 2;
        const screenY = (body.position.y - camera.y) * camera.zoom + canvas.height / 2;
        const radius = body.size * camera.zoom;
        drawGlow(screenX, screenY, radius, body.glow);
        ctx.fillStyle = body.color;
        ctx.beginPath();
        ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
        ctx.fill();

        if (body.type === "black-hole") {
          ctx.strokeStyle = "rgba(120, 150, 255, 0.6)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.ellipse(screenX, screenY, radius * 1.8, radius * 0.5, spin * 0.5, 0, Math.PI * 2);
          ctx.stroke();
        }
      };

      const updatePositions = (delta) => {
        spin += delta * 0.0008;
        bodies.forEach((body) => {
          if (body.orbit) {
            body.orbit.angle += body.orbit.speed * delta;
            const x = Math.cos(body.orbit.angle + spin) * body.orbit.radius;
            const y = Math.sin(body.orbit.angle + spin) * body.orbit.radius * Math.cos(body.orbit.tilt);
            body.position = { x, y };
          } else if (body.wobble) {
            body.position.x += Math.sin(spin) * body.wobble.x;
            body.position.y += Math.cos(spin * 0.7) * body.wobble.y;
          }
        });

        moons.forEach((moon) => {
          const parent = bodies.find((body) => body.name === moon.parent);
          if (!parent) return;
          moon.orbit.angle += moon.orbit.speed * delta;
          const x = Math.cos(moon.orbit.angle + spin) * moon.orbit.radius;
          const y = Math.sin(moon.orbit.angle + spin) * moon.orbit.radius * Math.cos(moon.orbit.tilt);
          moon.position = { x: parent.position.x + x, y: parent.position.y + y };
        });
      };

      const drawOrbit = (radius, tilt, color) => {
        const centerX = canvas.width / 2 - camera.x * camera.zoom;
        const centerY = canvas.height / 2 - camera.y * camera.zoom;
        const scaleY = Math.cos(tilt);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        for (let i = 0; i <= 160; i += 1) {
          const angle = (Math.PI * 2 * i) / 160;
          const x = centerX + Math.cos(angle + spin) * radius * camera.zoom;
          const y = centerY + Math.sin(angle + spin) * radius * scaleY * camera.zoom;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.stroke();
      };

      const drawStars = () => {
        ctx.save();
        ctx.fillStyle = "#d8deff";
        stars.forEach((star) => {
          const x = (star.x - camera.x * 0.2) + canvas.width / 2;
          const y = (star.y - camera.y * 0.2) + canvas.height / 2;
          ctx.globalAlpha = star.alpha;
          ctx.beginPath();
          ctx.arc(x, y, star.size, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.restore();
      };

      const drawScene = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawStars();
        orbitDefs.forEach((orbit) => drawOrbit(orbit.radius, orbit.tilt, orbit.color));
        bodies.forEach(drawBody);
        moons.forEach(drawBody);
      };

      const focusOn = (target) => {
        camera.targetX = target.position.x;
        camera.targetY = target.position.y;
        camera.targetZoom = target.focusZoom || 2;
        zoomInput.value = camera.targetZoom.toFixed(2);
      };

      const onPointerDown = (event) => {
        mouse.down = true;
        mouse.x = event.clientX;
        mouse.y = event.clientY;

        const clicked = [...bodies, ...moons].find((body) => {
          const screenX = (body.position.x - camera.x) * camera.zoom + canvas.width / 2;
          const screenY = (body.position.y - camera.y) * camera.zoom + canvas.height / 2;
          const radius = body.size * camera.zoom;
          return Math.hypot(event.clientX - screenX, event.clientY - screenY) <= radius + 6;
        });

        if (clicked) {
          focusOn(clicked);
        }
      };

      const onPointerMove = (event) => {
        if (!mouse.down) return;
        const dx = event.clientX - mouse.x;
        const dy = event.clientY - mouse.y;
        mouse.x = event.clientX;
        mouse.y = event.clientY;
        camera.targetX -= dx / camera.zoom;
        camera.targetY -= dy / camera.zoom;
      };

      const onPointerUp = () => {
        mouse.down = false;
      };

      const onWheel = (event) => {
        const zoomFactor = event.deltaY > 0 ? 0.92 : 1.08;
        camera.targetZoom = Math.min(3.2, Math.max(0.4, camera.targetZoom * zoomFactor));
        zoomInput.value = camera.targetZoom.toFixed(2);
      };

      zoomInput.addEventListener("input", () => {
        camera.targetZoom = Number(zoomInput.value);
      });

      const step = (timestamp) => {
        if (!step.last) step.last = timestamp;
        const delta = timestamp - step.last;
        step.last = timestamp;

        updatePositions(delta);
        camera.x += (camera.targetX - camera.x) * 0.08;
        camera.y += (camera.targetY - camera.y) * 0.08;
        camera.zoom += (camera.targetZoom - camera.zoom) * 0.1;

        drawScene();
        requestAnimationFrame(step);
      };

      canvas.addEventListener("pointerdown", onPointerDown);
      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
      window.addEventListener("wheel", onWheel, { passive: true });
      window.addEventListener("resize", resize);

      resize();
      requestAnimationFrame(step);
    </script>
  </body>
</html>
